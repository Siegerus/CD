1. Название переменной не должно начинаться с цифры. Имя должнл быть в формате camelcase (первое слово с маленикой буквы, последубщие с большой)

2.   var - переменная будет видна  скриптом даже до того, как объявлена в коде.      let -  содаётся только тогда, когда код до геё доходит , скрипт её увидит только
если запустить его после её объявления. Поэтому let используется всегда, т.к. более оптимизированный вариант. Ели let огранияить {} , то  она будет видна только внутри них. const - константа, её нельзя поменять, в остальном аналогична  let .

3. Всего есть 6 типов данных - строка, число, логический,null, undefined, объект. Есть также 7ой - символ.

infinity- получим при попытке поделить на ноль
NaN- если совершать нелогические, нематематические действия с цифрами.
undefined - что то присутствует в коде, но значения не имеет - значение не определено.
null - чего то в коде просто нет.

Объект - это комплексный тип данных, он может включать в себя все остальные. Св-ва объекта (методы), пишуться в {}  - по сути это функции.

4. У массивов, как и у обычных объектов есть ключи. В роли них выступают порядковые номера (начинаются с 0).
5. Все данные, которые мы получаем от пользователя будут иметь тип данных - строка.
 
6. Название функции  должно быть глаголом с припиской дейсьвия, которое выполняеться. Сначала глагол -потом то, над чем проиходит это действие.
7 . Если объявить переменную внутри функции, то вижна она будет только внурни неё - локальная переменная.  Две одинаковых переменных - одна локальная внутри
функции и другая снаружи - это две разных переменные
Функция сначала пытаеться найти переменную внутри себя, а потом уже ищет внешние
8.замыкание - это функция со всеми внешними переменными, которые ей доступны

Задвину про замыкания, чтобы каждый догнал.
У нас есть две функции:

const func1 = function () {
  let count = 0;
  function inner() {
    ++count;
  }
  inner();
  return count;
}

const  func2 = function (){
  let count = 0;
  return function(){
    return ++count;
  }
}

У обеих функций внутри имеется переменная и вложенная функция. И обе они делают примерно одно и то же: при вызове увеличивают переменную count и выводят её.
Так в чём же между ними разница? Попробуем вызвать каждую из них по несколько раз:

console.log(func1());  //1
console.log(func1());  //1
console.log(func1());  //1

const counter = func2();
console.log(counter());  //1
console.log(counter());  //2
console.log(counter());  //3

Первая функция при каждом вызове выводит в консоль одно и то же значение. Она отрабатывает и сразу умирает. А вот вторая функция между вызовами сохраняет предыдущее значение и при втором вызове в переменной count находится уже не 0, а 1 от первого вызова. Функция хранит это значение, как бы замыкает его в себе. Это и есть замыкание.

Вы можете спросить, а нафига ты func2 так c подвыпертом вызвал: сначала создал какой-то стремный counter, а потом ещё раз вызвал?
Простой вызов func2() вернёт нам внутреннюю функцию, какая она там записана в виде текста, не вызвав её. Поэтому выведется что-то типа (в node.js):

console.log(func())  // [Function (anonymous)]

Совсем не то что надо. Мы могли бы вызвать её вместе с внутренней таким образом func2()() и тогда результат её работы:

console.log(func2()())  // 1
console.log(func2()())  // 1
console.log(func2()())  // 1

будет аналогичен работе func1()
А сделав так:

const counter = func2();

Мы создали замыкание
Кто-то может возмутиться: э братуха, чё там нам опять затираешь? Можно же было сделать так, каждый ровный пацан знает:

let count = 0;
const counter  = function (){
  return ++count;
}
console.log(counter)  // 1
console.log(counter)  // 2
console.log(counter)  // 3

Работает так же и нафига замыканий не надо! Я отвечу: а поясни за let count, который наверху мотыляется? Это ж глобальная переменная, а глобальных переменных следует всячески избегать, потому что каждая встречная-поперечная функция, каждый if и цикл может взять её да и переопределить. И потому в замыканиях задействовано как минимум две функции. Внешняя- просто обертка, которая не дает всяким встречным-поперечным лапать её святую переменную count. С этой святой переменной имеет право работать только внутренняя функция. Вот для чего их две

--------------------------------------------------------------

Почему замыкание не сохраняется? Потому что ты не сохраняешь ссылку на возвращаемую функцию. Каждый раз, когда ты вызываешь func2(), создается новая анонимная функция с новым собственным лексическим окружением, где count снова инициализируется значением 0. Таким образом, каждый такой вызов начинается "с чистого листа".

Чтобы увидеть эффект замыкания и как значение count сохраняется между вызовами, нужно сохранить результат первого вызова func2() в переменную и затем многократно вызывать эту переменную.

Когда ты выполняешь let counter = func2(); , происходит следующее:

1. Инициализация counter:

o Вызывается func2, которая создает и инициализирует переменную count равной 0.
o func2 затем создает и возвращает анонимную функцию. Эта анонимная функция имеет доступ к переменной count через замыкание.

2. Сохранение анонимной функции в counter:
o Теперь переменная counter ссылается на эту анонимную функцию. Важно понимать, что это не просто копия кода функции; это функция вместе с её лексическим окружением, где живет переменная count.

3. Последующие вызовы counter():
o Каждый раз, когда ты вызываешь counter(), ты вызываешь одну и ту же анонимную функцию, которая ссылается на одну и ту же переменную count.
o Поскольку эта переменная сохранена в замыкании, она не пересоздается с каждым вызовом; она сохраняет свое значение между вызовами. Таким образом, каждый вызов увеличивает значение count на единицу.


Для тех, кто не понял 2ую задачу, пишу этот пост.
Изначально у нас запускается обычная функция sum(a), хоть даже с одним аргументом. После чего идёт инициализация функции f(b) и преобразования к примитиву функции f.

Как работает с одним аргументом: подаётся единичный аргумент, и всё также возвращается функция "f", которая имеет код, преобразующийся в примитив к "return currentsum" с помощью строчек: f.toString = ...

Как работает с несколькими аргументами: тут всё также просто. Функция в конце каждого "цикла" возвращает функцию "f" (тут надо понять, что возвращается именно функция,а не результат её выполнения), которая выполняется в том случае, если дальше присутствуют аргументы.

Как функция понимает, что дальше нет аргументов и показывает результат? Функция, по сути, в данном случае этого и не понимает. Она лишь видит, что её вызывает alert (который вызывает её только в том случае, когда все "циклы" пройдены, а значит аргументы закончились), и выводит то, что ей нужно вывести через примитив, то есть "return currentSum".

1. Рекурсия. Последняя задача. Цепочка вызовов св-в объектов
2.Декораторы.  Последний пример с обёрткой.
3. Привязка контекста this к функции. Последний пример с обёрткой.
"Главное запомнить, что return function возвращает "улучшенную" функцию вместе с окружением. То бишь запоминает локальные переменные функции в той переменной, куда мы сохраняем эту "улучшенную" функцию. Это становится довольно удобно, когда ты понимаешь, как это работает. Просто проверь, что хранится в новой переменной, куда мы это сохраняем и всё встанет на свои места."


Не понял одну строку в коде примеси
handlers.splice(i--, 1);
i-- - это постфиксный декремент, следовательно удаляется i-й элемент, после чего переменная i будет уменьшена на единицу.



-Обёртка нужна в том числе и затем, что бы потом вызвать эту функцию после декоратора с теми же аргументами. Функция-обёртка это ф-ция, которую мы будем потом
вызывать второй (та, которая была изначально, теперь она после декоратора).

-Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится. Выполнение функции останавливается, пока строка с await не выполнится


Сортировка таблицы
let tbody = document.querySelector('tbody')
let arr = Array.from(tbody.children)

tbody.innerHTML = ''

arr.sort((a, b) => {
const textA = a.firstElementChild.textContent
const textB = b.firstElementChild.textContent

return textA > textB ? 1 : -1
})

tbody.append(...arr)

-всплывает сам факт, тип события (клик, ховер и т.д)
-dispatchEvent - это имменно запуск события. Что именно будет происходить на это событие - это уже пишем в обработчике
dispatchEvent вызывает событие. Грубо говоря, скрипт сам выполнил/запустил действие и обработчик это действие поймал.

Очень сжат. Посмотри лекции Тимура Шемсединова! Он классный препод, грамотный. Но вот там конечно будет сто раз тяжелее для входа с ноля. И подскажи тогда читателя учебник написанный НЕ сложнее... за исключением "ДжаваСкрипт для детей".
