1. Тег <small> уменьшает размер шрифта на единицу по сравнению с обычным текстом. В HTML размер шрифта измеряется в условных единицах от 1 до 7, средний размер текста, используемый по умолчанию, принят 3. Таким образом, добавление тега <small> уменьшает текст на одну условную единицу.

2.Если заголовка секции в макете проекта нет, то всё равно его делаем и скрываем.

3. Тег <time> используется для отображения точного времени и даты на веб-странице. Он помечает текст внутри элемента как дату, время или оба значения. 
Пример использования: <time datetime="2023-03-13T12:00:00Z">13 марта 2023 года</time>.

4.Тег <blockquote> в HTML используется для определения в документе блочной цитаты (длинной цитаты внутри документа). 
Атрибут <cite>, вложенный в тег <blockquote>, указывает на источник цитаты. В качестве значения может быть указан как относительный, так и абсолютный URL-адрес. 
Для коротких (строчных) цитат в документе существует специальный HTML-элемент <q>. 
 
5.Нужно обязательнозадавать widht height тегам img.

6. Варианты для отображения нужной картинки на ретина дисплеях: 
для png и jpeg :
<img src="cat.jpg" alt="Котик." width="360" height="240" srcset="cat-360px.jpg 1x, cat-720px.jpg 2x, cat-1080px.jpg 3x">
<img src="small.jpg" srcset="medium.jpg 1.5dppx, large.jpg 2dppx" alt="Адаптивное изображение">
для фона:  
background-image: url("img.png");
background-size : 200px auto   - задаём размер и потом
медиаправило -
@media (min-resolution: 2dppx) {
    background-image: url("big-img.png");
  }
https://htmlacademy.ru/blog/html/adaptive-srcset?ysclid=m6vugde7uq983232435

7.img {
  height: auto;
  width: 100%;
/* свойство max-width, позволит лучше контролировать изображение */
  max-width: 720px;
}
 
8. Для webp изображений.
<picture>
   <source type="image/svg+xml" srcset="logo.svg">
   <source type="image/webp" srcset="logo.webp">
   <img src="logo.png" alt="investing.com">
</picture>

9.  Разные размеры apple фавиконок попробовать прописать в webmanifest вместо head.

10. Обратите внимание на то, что когда функция завершит работу, её контекст выполнения извлекается из стека вызовов, но её лексическое окружение может быть удалено из памяти, а может и остаться там. Это зависит от того, существуют ли в других лексических окружениях ссылки на данное лексическое окружение в виде ссылок на внешнее лексическое окружение.
11.Опциональные цепочки. "?"
 let html = document.querySelector('.elem')?.innerHTML;    // будет undefined,а не null,  если элемента нет.

let user = null;
alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
Переменная должна быть объявлена.
Если переменной user вообще нет, то user?.anything приведёт к ошибке. 

12.Деструктуризация в JavaScript — это метод, который позволяет распаковывать значения из массивов или объектов в отдельные переменные.
const user = { name: "Tom", age: 24, phone: "+367438787", email: "tom@gmail.com" };
const {name, email} = user;
console.log(name);  // Tom
console.log(email);  // tom@gmail.com

const fruits = ["Banana", "Orange", "Apple", "Mango"];
let [firstFruit, secondFruit] = fruits;
console.log(firstFruit);  // Banana
console.log(secondFruit);  // Orange

Тезисы.
- Для каждого блока отдельный файл.
- Писать название классов первыми, потом остальные атрибуты.
- Писать целиком, без сокращений.
- Map`ы - карты кода. Нужны, что бы браузер мог прочесть scss файлы.
- Правая кнопка - Format Document на min файле стиля и всё отобразится, как в обычном css файле.
- Навигация по блокам через ctrl+ click.
- При подключении шрифтов, смотреть чтобы в девтулс была поставлена галочка про кеш. Подключенные файлы шрифтов тоже есть во вкладке Network.
- Если несколько шрифтов -  основной шрифт указываем в font family для всего проекта. Где другой шрифт - задаём в стилях его, где нужно. ? =проверить.
- Селекторы, разделённые запятой, записаны на новых строках.
- Контент (Например обязательные тайтлы секций, которые не указаны в макете) можно скрывать утилитарным классом visually-hidden, чтобы он был доступен для скринридеров и поисковиков.


БЭМ.
1.Если мы миксуем два класса блока, то один из этих блоков (1) «атомарен», ограничивается строго одним узлом и не имеет элементов, а всё, что внутри, полностью принадлежит другому блоку (2), и если элементы блока (2) имеют какие-либо особенности, завязанные на наличие блока (1), то стили блока (2) всё равно задаём через модификаторы элементов блока (2). 
Этот «атомарный» блок не обязательно должен быть в прямом смысле атомарен, то есть работать как атомарный класс, но важно, чтобы у него не было элементов и блок устанавливал что-то одно. К примеру, блок theme, который определяет внешний вид сайта, блок row, который отвечает за сеточные стили, блок visually-hidden, который доступно скрывает элементы, и так далее.

2.Для всех блоков -компонентов , даже самых маленьких, создаётся отдельный файл.

3.Блокам ("block-block") задаются только стили, отступы задаются блоку  миксом, как элементу родительсякого блока  ("block__element).  Модификаторами тоже внешние отступы не задаём. Внутренние размеры (padding) всегда у блока, а внешние (margin) — у элемента.

4.Для блока не рекомендуется использовать CSS-свойства width и max-width. Нужно, чтобы блок занимал всю отведённую для него ширину, весь экран, всю ширину колонки, всю ширину ячейки. Так его проще переиспользовать.

5.Блок управляет только своими элементами и не должен хотеть управлять вложенными блоками и их элементами. 

6.Блок не должен влиять на своё окружение, блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование.

7.Когда  говорят «стили, отвечающие за позиционирование», то имеют в виду, что элемент будет либо смещён относительно своего места по умолчанию, либо «вырван» из потока. По этой логике position: relative допустимо задавать для блока.
Какие ещё свойства могут быть у блока? Свойства, которые отвечают за сетку блока в целом, допустим, display: flex, display: grid. А что именно и где будет расположено — определяют элементы блока.
Для блока можно использовать свойства, которые отвечают за его внешний вид: цвет фона, цвет текста, его размер, декоративные линии и так далее.

8.Изменение оформления блока производится при помощи установки/снятия модификатора.
  К примеру, если нужно сделать чекбокс недоступным для изменения пользователем, добавляем ему класс checkbox--disabled, который соответствует состоянию disabled.

9.БЭМ запрещает задавать блокам ширину и внешние отступы, а «атомарные» блоки — это не совсем блоки по БЭМ, скорее это служебные блоки, в которых мы свободны устанавливать всё что угодно. То есть мы вполне легально можем использовать в проекте для выравнивания содержимого на странице блок container, который задаёт и ширину, и внешние отступы.

10.Стили блоков конфликтуют, они устанавливают одно и то же свойство и тут кто последний, тот и прав.
Эту проблему можно обойти, если добавить в перечень требований к проекту ещё одно: сначала подключать простые блоки, затем более крупные.
Но всё же таких конфликтов лучше избегать совсем.

11.Анализируем функциональность блока и следим за тем, чтобы он не стал «жадным».
Если класс для блока, помимо общих стилей, содержит декоративные стили, сеточные стили и другие, смотрим, можно ли поделить этот блок на несколько так, чтобы по возможности один блок отвечал за что-то одно (один блок-одна функция).
К примеру, создаём блок, который отвечает только за сетку; блок, который отвечает за внешний вид содержимого; блок, который отвечает за выравнивание. И всё это будут разные блоки.

12. Модификатор Это вариативность блока или элемента. Всегда только внешняя.

13. Если микс - сначала указываем класс элемента родительского блока, потом класс блока.

14. Пример комбинирования. Блок шапка, элемент шапки - лого. И элемент шапки img, который в свою очередь относится к элементу лого.
<header class="main-header">
  <a href="" class="main-header__logo">
    <img class="main-header__logo-image"></img>
  </a>
</header>

15.


